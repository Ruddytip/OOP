#pragma once
#include <iostream>
#include <vector>

// Масти: пики, трефы, червы, бубны
enum{spade = 0, club = 1, heart = 2, diamond = 3};
// Валет, Дама, Король, Туз, Джокер
enum{jack = 11, queen = 12, king = 13, ace = 1};

// Создать класс Card, описывающий карту в игре БлэкДжек.
// У этого класса должно быть три поля: масть, значение карты и положение карты (вверх лицом или рубашкой).
// Сделать поля масть и значение карты типом перечисления (enum). Положение карты - тип bool. Также в этом классе должно быть два метода:
// метод Flip(), который переворачивает карту, т.е. если она была рубашкой вверх, то он ее поворачивает лицом вверх, и наоборот.
// метод GetValue(), который возвращает значение карты, пока можно считать, что туз = 1.
// Игровая карта
class Card{
private:
    // Масть карты
    unsigned char suit;
    // Значение в виде очков
    unsigned short face;
    // Положение карты
    bool dir;
public:
    // Конструктор - значение, масть
    Card(const unsigned short _face, const unsigned char _suit);
    // Переворачивает карту, т.е. если она была рубашкой вверх, то он ее поворачивает лицом вверх, и наоборот
    void Flip();
    // Возвращает значение карты, пока можно считать, что туз = 1
    unsigned short GetValue() const;
    // Возвращает положение карты
    bool getDir() const;
    // Написать перегрузку оператора вывода для класса Card. Если карта перевернута рубашкой вверх (мы ее не видим),
    // вывести ХХ, если мы ее видим, вывести масть и номинал карты.
    friend std::ostream& operator<<(std::ostream &out, const Card& crd){
        if(crd.dir){
            switch(crd.suit){
                case spade: out   << "Spade ";   break;
                case club: out    << "Club ";    break;
                case heart: out   << "Heart ";   break;
                case diamond: out << "Diamond "; break;
            }
            switch(crd.face){
                case jack: out  << "Jack";   break;
                case queen: out << "Queen";  break;
                case king: out  << "King";   break;
                case ace: out   << "Ace";    break;
                default: out    << crd.face; break;
            }
        } else{
            out << "XX";
        }
        return out;
    }
};

// Реализовать класс Hand, который представляет собой коллекцию карт.
// В классе будет одно поле: вектор указателей карт (удобно использовать вектор, т.к. это по сути динамический массив, а тип его элементов должен быть - указатель на объекты класса Card).
// Также в классе Hand должно быть 3 метода:
// • метод Add, который добавляет в коллекцию карт новую карту, соответственно он принимает в качестве параметра указатель на новую карту
// • метод Clear, который очищает руку от карт
// • метод GetValue, который возвращает сумму очков карт руки (здесь предусмотреть возможность того, что туз может быть равен 11).
// Карты в руке (по сути мини-колода)
class Hand{
protected:
    std::vector<Card> cards;
public:
    // Добавляет карту
    void add(const Card _card);
    // Очищает руку
    void clear();
    // возвращает сумму очков карт руки (здесь предусмотреть возможность того, что туз может быть равен 11)
    int GetValue() const;
};

// Согласно иерархии классов, которая представлена в методичке к уроку 3, от класса Hand наследует класс GenericPlayer,
// который обобщенно представляет игрока, ведь у нас будет два типа игроков - человек и компьютер. Создать класс GenericPlayer, в который добавить поле name - имя игрока. Также добавить 3 метода:
// • IsHitting() - чисто виртуальная функция, возвращает информацию, нужна ли игроку еще одна карта.
// • IsBoosted() - возвращает bool значение, есть ли у игрока перебор
// • Bust() - выводит на экран имя игрока и объявляет, что у него перебор.
class GenericPlayer: public Hand{
protected:
    std::string name;
public:
    GenericPlayer(const std::string _name);
    // возвращает информацию, нужна ли игроку еще одна карта
    virtual bool IsHitting() const = 0;
    // возвращает bool значение, есть ли у игрока перебор
    bool IsBoosted() const;
    // выводит на экран имя игрока и объявляет, что у него перебор
    void Bust() const;
    // Также для класса GenericPlayer написать перегрузку оператора вывода, который должен отображать имя игрока и его карты, а также общую сумму очков его карт.
    friend std::ostream& operator<<(std::ostream &out, const GenericPlayer& plr){
        out << "Player " << plr.name << ":\n";
        for(unsigned int i = 0; i < plr.cards.size(); ++i)
            out << plr.cards[i] << std::endl;
        if(plr.cards[0].getDir())
            out << "Total points: " << plr.GetValue() << std::endl;
        return out;
    }
};

// Реализовать класс Player, который наследует от класса GenericPlayer. У этого класса будет 4 метода:
// • virtual bool IsHitting() const - реализация чисто виртуальной функции базового класса. Метод спрашивает у пользователя, нужна ли ему еще одна карта и возвращает ответ пользователя в виде true или false.
// • void Win() const- выводит на экран имя игрока и сообщение, что он выиграл.
// • void Lose() const - выводит на экран имя игрока и сообщение, что он проиграл.
// • void Push() const - выводит на экран имя игрока и сообщение, что он сыграл вничью.
class Player : public GenericPlayer{
private:
public:
    Player(const std::string _name);
    // спрашивает у пользователя, нужна ли ему еще одна карта и возвращает ответ пользователя в виде true или false
    bool IsHitting() const override;
    // выводит на экран имя игрока и сообщение, что он выиграл
    void Win() const;
    // выводит на экран имя игрока и сообщение, что он проиграл
    void Lose() const;
    // выводит на экран имя игрока и сообщение, что он сыграл вничью
    void Push() const;
};

// Реализовать класс House, который представляет дилера. Этот класс наследует от класса GenericPlayer. У него есть 2 метода:
// • virtual bool IsHitting() const - метод указывает, нужна ли дилеру еще одна карта. Если у дилера не больше 16 очков, то он берет еще одну карту.
// • void FlipFirstCard() - метод переворачивает первую карту дилера.
class House : public GenericPlayer{
private:
public:
    House(const std::string _name);
    // метод указывает, нужна ли дилеру еще одна карта. Если у дилера не больше 16 очков, то он берет еще одну карту
    bool IsHitting() const override;
    // метод переворачивает первую карту дилера
    void FlipFirstCard();
};

// Task 3. Создать класс Deck, который наследует от класса Hand и представляет собой колоду карт. Класс Deck имеет 4 метода:
// • vold Populate() - Создает стандартную колоду из 52 карт, вызывается из конструктора.
// • void Shuffle() - Метод, который тасует карты, можно использовать функцию из алгоритмов STL random_shuffle
// • vold Deal (Hand& aHand) - метод, который раздает в руку одну карту
// • void AddltionalCards (GenericPlayer& aGenerlcPlayer) - раздает игроку дополнительные карты до тех пор, пока он может и хочет их получать
// Обратите внимание на применение полиморфизма. В каких методах применяется этот принцип ООП?
class Deck : public Hand{
private:
public:
    // Конструктор, создает стандартную колоду из 52 карт
    Deck();
    // Создает стандартную колоду из 52 карт, вызывается из конструктора
    void Populate();
    // Метод, который тасует карты, можно использовать функцию из алгоритмов STL random_shuffle
    void Shuffle();
    // Метод, который раздает в руку одну карту
    void Deal(Hand& aHand);
    // Раздает игроку дополнительные карты до тех пор, пока он может и хочет их получать
    void AddltionalCards(GenericPlayer& aGenerlcPlayer);
};

// Task 4. Реализовать класс Game, который представляет собой основной процесс игры. У этого класса будет 3 поля:
// • колода карт
// • рука дилера
// • вектор игроков.
// Конструктор класса принимает в качестве параметра вектор имен игроков и создает объекты самих игроков.
// В конструкторе создается колода карт и затем перемешивается.
// Также класс имеет один метод play(). В этом методе раздаются каждому игроку по две стартовые карты,
// а первая карта дилера прячется. Далее выводится на экран информация о картах каждого игра, в т.ч. и для дилера.
// Затем раздаются игрокам дополнительные карты. Потом показывается первая карта дилера и дилер набирает карты, если ему надо.
// После этого выводится сообщение, кто победил, а кто проиграл. В конце руки всех игроков очищаются.
class Game{
private:
    Deck deck;
    Hand hand;
    std::vector<Player> players;
public:
    // Конструктор класса принимает в качестве параметра вектор имен игроков и создает объекты самих игроков.
    Game(std::vector<std::string> names);
    ~Game();
    // В этом методе раздаются каждому игроку по две стартовые карты,
    // а первая карта дилера прячется. Далее выводится на экран информация о картах каждого игра, в т.ч. и для дилера.
    // Затем раздаются игрокам дополнительные карты. Потом показывается первая карта дилера и дилер набирает карты, если ему надо.
    // После этого выводится сообщение, кто победил, а кто проиграл. В конце руки всех игроков очищаются
    void play();
};